// Маркеры памяти
// void - пустой тип данных, не занимает места в памяти
// int  - целые числа
// char - одиночные символы
// long - большие целые числа

// Константы для обозначения ножек контроллера, подключенных к кнопкам
const int PIN_BUTTON1 = 2;  // Ножка для кнопки 1
const int PIN_BUTTON2 = 3;  // Ножка для кнопки 2

//----------------------------------------
#include "TM1637Display.h"  // Библиотека для работы с дисплеем TM1637

// Объект класса для взаимодействия с дисплеем TM1637
TM1637Display display(3, 2);  // Аргументы: CLK (пин 3), DIO (пин 2)

// Символьные представления некоторых элементов для дисплея
const uint8_t tire = { SEG_G };            // Гора типа "-": одна горизонтальная линия
const uint8_t C = { SEG_A | SEG_F | SEG_E | SEG_D };  // Буква 'C'
const uint8_t DONE[] = {                     // Слово "done":
    SEG_B | SEG_C | SEG_D | SEG_E | SEG_G,  // Символ 'd' (нижний регистр)
    SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F,  // Символ 'O'
    SEG_C | SEG_E | SEG_G,                   // Символ 'n'
    SEG_A | SEG_D | SEG_E | SEG_F | SEG_G    // Символ 'E'
};

// Функция "music", сейчас пустая, возможно будет заполняться музыкой позднее
void mus() {
  // Пока ничего не делает
}

// Функция игры, пока возвращает произвольный результат (score)
int play() {
  return 0;  // Здесь временно возвращаем нулевое значение
}

// Проверяем состояние кнопки 1
void knop_one() {
  int buttonState1 = digitalRead(PIN_BUTTON1);  // Читаем состояние кнопки
  Serial.println(buttonState1);                 // Выводим состояние в монитор порта
  if (!buttonState1) {                          // Если кнопка не нажата
    delay(50);                                  // Небольшая пауза
    return;                                     // Выход из функции
  }
}

// Аналогично для второй кнопки
void knop_two() {
  int buttonState2 = digitalRead(PIN_BUTTON2);  // Читаем состояние кнопки
  Serial.println(buttonState2);                 // Выводим состояние в монитор порта
  if (!buttonState2) {                          // Если кнопка не нажата
    delay(50);                                  // Пауза
    return;                                     // Выход из функции
  }
}

// Фиктивная функция для освещения пикселя на матрице (не реализована)
void pik_in_mat(int nom, int color) {
  // Пустое тело функции
}

// Очистка виртуальной матрицы (не реализовано)
void clear_mat() {
  // Ничего не делается
}

// Функция для вывода числа на четырёхсимвольный дисплей
void indikator(int score) {
  display.showNumberDec(score, true, 4, 0);  // Показываем счёт на экране целиком
  delay(500);                                // Задерживаем программу на полсекунды
  display.clear();                           // Чистим экран
}

// Основной метод настроек устройства
void setup() {
  int s = 0;                                 // Переменная состояния игры
  Serial.begin(9600);                         // Запускаем последовательный интерфейс для отладки
  pinMode(PIN_BUTTON1, INPUT_PULLUP);         // Настраиваем первую кнопку как вход с подтягивающим резистором
  pinMode(PIN_BUTTON2, INPUT_PULLUP);         // То же самое для второй кнопки

  display.setBrightness(4);                  // Устанавливаем яркость экрана (от 0 до 7)
  display.clear();                            // Чистка экрана

  // Последовательная демонстрация знака "-" на каждом сегменте
  for (int i = 0; i <= 3; ++i) {
    display.setSegments(tire, 1, i);          // Включаем сегмент
    delay(200);                               // Немного ждём
  }

  display.clear();                            // Стартовая очистка
  display.setSegments(DONE, 4, 0);            // Печатаем слово "done"
  delay(500);                                 // Паузы между действиями
  display.clear();                            // Заканчиваем очисткой экрана
}

// Основная петля программы
void loop() {
  // Определение переменной состояния игры
  static int state = 1;                       // Начальное состояние ожидания

  // Переключение состояний в зависимости от условий
  switch(state) {
    case 1:                                   // Ожидание начала игры
      if (knop_one() || knop_two()) {         // Если хотя бы одна кнопка была нажата
        state = 2;                             // Переводим игру в подготовительное состояние
      }
      break;

    case 2:                                   // Подготовительная фаза
      state = 3;                              // Сразу переходим к игре
      break;

    case 3:                                   // Активная фаза игры
      int score = play();                      // Выполняем игровую сессию и получаем очки
      state = 4;                              // Переходим к состоянию окончания игры
      break;

    case 4:                                   // Итоги игры
      indikator(score);                        // Выводим итоговые очки на дисплей
      break;

    default:                                  // По умолчанию ожидаем
      break;
  }
}